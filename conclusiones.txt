Exercise 1: E2E Automation
Option 3: Purchase Flow in http://opencart.abstracta.us/

The challenge:
The main challenge when completing this test was a bug in the test that presented itself in the checkout page. After clicking the "#button-account" to continue to the billing section, it threw an error that clear() was being called on 'undefined', this means that the "#input-payment-firstname" element was not being found.

Considering the ui is an accordion, my first guess was that the ui was not updating fast enough. I tried adding a wait period of 2, then 5, then 10 seconds and the error was still present.

Digging deeper, my next guess was that there was a delay in the ajax response from the server, so I tried intersecting and waiting for the response, but results were inconsistent, sometimes they worked and sometimes not. 

So I believed there was a race condition, and tried extending the wait period with no success. At this point I discarded my initial hypothesis (that the bug was because the ui was not loading) and tried to find another cause for the bug. 

I contemplated it could be a caching issue and started to see if there was success in clearing the cache. I ran the test both in headless mode and also in the cypress app. In the app I noticed a suspicious page reload during the execution. This made me check the cy.vitit() calls and I noticed an inconsistency in the checkout page. The url was an absolute url (starting with "http://...") instead of a relative url (starting with "/index..."). When the url was set to relative, to match the others, the tests ran succesfully and consistently. With the solution in place, I cleaned up unneccesary code. 

Reflecting on the root cause, using an absolute url likely caused Cypress to treat this as a new page navigation, potentially clearing session state or cookies needed for the checkout flow. The relative URL maintained the same session context.

Key Learnings:
- URL navigation patterns matter. Relative vs absolute urls can affect session state and cookie persistence in ways that aren't immediately obvious.

- Visual debugging (running tests in non-headless mode) can provide insights that aren't apparent from logs alone.

- Understanding the testing framework's behavior is as important as understanding the application being tested.

Future Improvements: 
- Add more properties to the product objects and check that the cart renders more data points correctly. 

- Add negative test cases with invalid data to verify error handling and validation messages.


Exercise 2: API Testing
Option 2: Pet CRUD in https://petstore.swagger.io/

The challenge:
The main challenge encountered during this exercise was understanding how to properly chain asynchronous API requests in Cypress. Initially, when attempting to retrieve a pet by ID immediately after creation, the GET request was receiving undefined values. This occurred because I was trying to use the response data outside of the request's promise chain, before the POST request had completed.

The solution was to properly chain the requests using .then() blocks, ensuring each operation completed before the next one began. This pattern became particularly important in Test 2, where I needed to chain POST → PUT → GET operations sequentially, with each step depending on data from the previous request.

Additionally, I discovered unexpected behavior in the PetStore API's ID generation: when creating a pet with "id: 0", "id: null", or without the "id" property at all, the API generates an extremely long numeric ID (e.g., 9223372036854776000) that subsequently fails on GET requests, returning a 404 or error response. To ensure test reliability, I implemented a workaround by generating random IDs in a valid range (Math.floor(Math.random() * 10000)) rather than relying on the API's auto-generation.

Key Learnings: 
- This was my first experience using Cypress for API testing rather than UI automation, and it proved to be an excellent tool in this context. I really enjoyed working with it. 

- Proper promise chaining is important when working with dependent API calls. Each request must complete and its response data must be available before dependent operations execute.

- The cy.request() command handles many HTTP concerns automatically (headers, status codes, JSON parsing) which streamlines the test writing process compared to raw HTTP libraries.

- Using dynamic test data (random IDs, fixture files) helps ensure test independence and reduces conflicts when running tests against shared environments.


Future Improvements: 
- Implement negative test cases to verify error handling: invalid pet IDs, malformed payloads, missing required fields, unauthorized operations.

- Add validation for edge cases: pets with minimal data, very long names, special characters in string fields, boundary values for numeric fields.

- Create reusable custom commands (e.g., cy.createPet(), cy.deletePet()) to reduce code duplication across tests.

